{
  "shaders": [
    {
      "name": "Bricks",
      "date": "2024-09-13",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nvoid main(void) {\n    vec4 a[6];\n    a[0] = vec4(1.0, 0.4, 0.4, 1.0);\n    a[1] = vec4(0.4, 1.0, 0.4, 1.0);\n    a[2] = vec4(0.9, 0.9, 0.4, 1.0);\n    a[5] = vec4(0.7, 0.5, 1.0, 1.0);\n    a[4] = vec4(0.3, 0.9, 0.9, 1.0);\n    a[3] = vec4(1.0, 0.6, 0.4, 1.0);\n\n    vec2 uv = gl_FragCoord.xy / resolution.xx;\n    float xColumn = floor(uv.x * 10.0 - time);\n    float offset = 6.0 * xColumn;\n    float yColumn = floor((uv.y * 10.0 + time + xColumn)/2.0 + offset);\n    float xBorder = step(0.2, mod(uv.x * 10.0 - time, 1.0));\n    float yBorder = step(0.2, mod(uv.y * 10.0 + time + xColumn, 2.0));\n    int colorIndex = int(mod(xColumn + yColumn, 6.0));\n\n    gl_FragColor = xBorder * yBorder *\n      vec4(1.0, 0.4, 0.2, 1.0) * mod(float(colorIndex + 1)/6.0 * gl_FragCoord.x/200.0, 1.0);\n      //a[colorIndex];\n}\n"
    },
    {
      "name": "Leaves",
      "date": "2024-09-14",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noisey(vec2 n) {return rand(floor(n)); }\n\nvoid main(void) {\n\tfloat zoom = 100.0;\n\n\tfloat angle = 0.4;\n\tvec2 t_coord = vec2(\n\t\t(sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y),\n\t  (sin(angle) * gl_FragCoord.y - cos(angle) * gl_FragCoord.x) + time * 100.0\n\t\t)/zoom;\n\n\tfloat noise_val = noisey(t_coord);\n\tvec2 origin = floor(t_coord);\n\n\torigin = origin + vec2(1.0, 0.0) * step(noise_val, 0.5);\n\torigin = origin + vec2(0.0, 1.0) * step(mod(noise_val, 0.5), 0.25);\n\n\tfloat dist = distance(origin, t_coord);\n\n\tfloat shadow_val = clamp(mod((1.0 - t_coord.x)*2.0, 2.0) + 0.3, 0.0, 1.0);\n\n\tnoise_val = mod(noise_val, 0.25)*4.0;\n\n\tfloat desx = step(noise_val, 0.95);\n\tfloat variance = (1.0 - noise_val)*15.0;\n\tvec4 col =\n\t\tvec4(noise_val*0.5, noise_val, 0.0, 1.0) * desx +\n\t\tvec4(1.0, 0.7 - variance, variance, 1.0) * (1.0 - desx);\n\n\tgl_FragColor = col * step(dist, 1.0) * shadow_val;\n}\n"
    },
    {
      "name": "Lava Lamp",
      "date": "2024-09-19",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float pi = 3.14159265;\nconst int amount = 40;\n\nfloat pointDistance(vec3 pos) {\n\treturn pow(clamp(1.0 - length((gl_FragCoord.xy - pos.xy) / pos.z), 0.0, 1.0), 2.0);\n}\n\nvoid main(void) {\n\t\n  float t = time/2.0 + 20.0;\n  float brightness = 0.0;\n  float size = 140.0;\n\n\tfor(int i = 0; i < amount; i ++) {\n\t\tfloat n = float(i) / float(amount);\n\t\tfloat x = mod(200.0 * t * sin(2.0 * pi * n+ 0.15), resolution.x*1.4) - resolution.x * 0.2;\n\t\tfloat y = mod(200.0 * t * cos(2.0 * pi * n), resolution.y*1.4) - resolution.y * 0.2;\n\t\tif(distance(vec2(x, y), gl_FragCoord.xy) > 3.0 * size) continue;\n\t\tfloat s = size * (2.0 + cos(2.0 * pi * n));\n\t\tfloat d = pointDistance(vec3(x, y, s));\n\t  brightness += d;\n\t\tif (brightness >= 1.0) break;\n\t}\n\tgl_FragColor = vec4(0.8, 0.8, 0.0, 1.0) * (step(0.5, brightness) + brightness*1.5) + vec4(0.5, 0.0, 0.5, 1.0);\n}"    
    },
    {
      "name": "Fibonnacci",
      "date": "2024-09-19",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat inCircle(float n, float o, float r) {\n\tfloat angle = 2.4 * n + time/10.0;\n\tvec2 circle = resolution/2.0 + sqrt(n) * o * vec2(sin(angle), cos(angle));\n\treturn distance(gl_FragCoord.xy, circle);\n}\n\nvoid main(void) {\n    vec2 center = resolution / 2.0;\n    gl_FragColor = vec4(0.0, 0.4, 0.0, 1.0);\n\n    float amount = 200.0;\n    float t_amount = mod(floor(time*30.0), amount * 2.0);\n    t_amount += step(amount, t_amount) * 2.0 * (amount - t_amount);\n\n    float o = 55.0;\n    float r = 80.0;\n    float d = distance(gl_FragCoord.xy, center);\n\n    float mini = floor(max(pow((d-r)/o, 2.0)-1.0,0.0));\n    float maxi = ceil(min(pow((d+r)/o, 2.0),t_amount));\n\n    const int MAX_ITER = 300; // must be >= possible maxi\n    for(int i = 0; i < MAX_ITER; i++) {\n        if(float(i) < mini) continue;\n        if(float(i) >= maxi) break;\n        float a = inCircle(float(i), o, r)/r;\n        float b = float(i)/amount/2.0+0.5;\n        if(a < 1.0) {\n            gl_FragColor = vec4(1.0, 1.0-b, b, 1.0) * (0.9 + a);\n            break;\n        }\n    }\n}\n"
    },
    {
      "name": "Symbol Landscape",
      "date": "2024-09-21",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 20.0;\nconst float angle = 0.5;\nconst vec4 color = vec4(1.0, 0.0, 0.7, 1.0);\n\nconst float pi = 3.14159265335;\nconst float scale = 100.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tfloat a; float b;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 1; vertex < 5; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex + 1), 2.0), floor(float(vertex) / 3.0));\n      float gradAngle = 2.0 * pi * rand(floor(vec2(pos/cScale)) + vertexOffset);\n      float gradX = sin(gradAngle);\n      float gradY = cos(gradAngle);\n      float oX = floor(pos.x/cScale) + float((mod(float(vertex), 2.0) == 0.0));\n      float oY = floor(pos.y/cScale) + float(vertex > 2);\n      oX = (pos.x - oX * cScale) / cScale;\n      oY = (pos.y - oY * cScale) / cScale;\n      if(vertex == 1) {\n      \ta = pow(oX, 3.0) * (oX * (oX * 6.0 - 15.0) + 10.0);\n      \tb = pow(oY, 3.0) * (oY * (oY * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex - 1] = gradX * oX + gradY * oY;\n\t\t}\n\t\tlayeredPV += cAmplitude * ((1.0 - b) * ((1.0 - a) * cV[0] + a * cV[1]) + b * ((1.0 - a) * cV[2] + a * cV[3]));\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nfloat ontrack(vec2 uv, vec4 p) {\n\tfloat type;\n\tvec2 corner;\n\tif(p == vec4(0.0)) return 0.0;\n\tif(length(p) == 1.0){\n\t\ttype = 0.0;\n\t\tif (p.x == 1.0) corner = vec2(1.0, 0.0);\n\t\tif (p.y == 1.0) corner = vec2(1.0, 1.0);\n\t\tif (p.z == 1.0) corner = vec2(0.0, 1.0);\n\t\tif (p.w == 1.0) corner = vec2(0.0, 0.0);\n\t} else if (length(p) == length(vec2(1.0))) {\n\t\tif(p == vec4(1.0, 0.0, 1.0, 0.0)) {type = 1.0; corner = vec2(0.0, 1.0);}\n\t\telse if(p == vec4(0.0, 1.0, 0.0, 1.0)) {type = 1.0; corner = vec2(0.0, 0.0);}\n\t\telse {\n\t\t\ttype = 2.0;\n\t\t\tif(p.x == 1.0) {\n\t\t\t\tif(p.y == 1.0) {\n\t\t\t\t\tcorner = vec2(1.0, 0.0);\n\t\t\t\t} else {\n\t\t\t\t\tcorner = vec2(0.0, 0.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(p.y == 1.0) {\n\t\t\t\t\tcorner = vec2(1.0, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tcorner = vec2(0.0, 1.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if(length(p) == length(vec3(1.0))) {\n\t\ttype = 3.0;\n\t\tif (p.x == 0.0) corner = vec2(0.0, 0.0);\n\t\tif (p.y == 0.0) corner = vec2(1.0, 0.0);\n\t\tif (p.z == 0.0) corner = vec2(1.0, 1.0);\n\t\tif (p.w == 0.0) corner = vec2(0.0, 1.0);\n\t} else {\n\t\ttype = 4.0;\n\t}\n\tfloat sv = mod(corner.x + corner.y, 2.0);\n  vec2 r_uv = (uv.xy * (1.0 - sv) + uv.yx * sv) * (-2.0 * corner + vec2(1.0)) + corner;\n\tif(type == 0.0) {\n\t\tif(r_uv.y < 0.5) return 1.0 - distance(r_uv.x, 0.5) * 2.0;\n\t\telse return max(1.0 - distance(r_uv, vec2(0.5)) * 2.0, 0.0);\n\t} else if (type == 1.0) {\n  \treturn 1.0 - distance(r_uv.x, 0.5) * 2.0;\n  } else if(type == 2.0) {\n    float dist = distance(r_uv, vec2(0.0)) * 2.0;\n    dist += 2.0 * (step(1.0, dist) * -dist + step(1.0, dist));\n    return max(dist, 0.0);\n  } else if (type == 3.0) {\n  \tif(r_uv.x < 0.5) return 1.0 - distance(r_uv.x, 0.5) * 2.0;\n  \telse return 1.0 - min(distance(r_uv.x, 0.5), distance(r_uv.y, 0.5)) * 2.0;\n  } else {\n  \treturn 1.0 - min(distance(r_uv.x, 0.5), distance(r_uv.y, 0.5)) * 2.0;\n  }\n}\n\nvec4 getFormAt(vec2 pos) {\n\tfloat aV = clamp(perlin(floor(pos)) * 0.6 + 0.8, 0.0, 1.0);\n\tfloat r = rand(floor(pos));\n\tvec4 outputs = vec4(0.0);\n\tif(mod(r,1.0) > aV) outputs.x = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.y = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.z = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.w = 1.0; r = mod(r * 2.0, 1.0);\n  return outputs;\n}\n\nvoid main(void) {\n\tfloat depth = max((resolution.y/1.5 - gl_FragCoord.y) / 1000.0, 0.0);\n\tvec2 p = gl_FragCoord.xy / depth + vec2(-100.0, 300.0) * time;\n\tp = vec2(sin(angle) * p.x + cos(angle) * p.y, sin(angle) * p.y - cos(angle) * p.x)/size;\n\n  float trackValue;\n\n\tif(mod(floor(p.x) + floor(p.y), 2.0) == 1.0) {\n\t  trackValue = ontrack(vec2(mod(p.x, 1.0), mod(p.y, 1.0)), getFormAt(p));\n  } else {\n  \tvec4 form = vec4(0.0);\n\n  \tform.x = getFormAt(p + vec2(-1.0, 0.0)).z;\n  \tform.y = getFormAt(p + vec2(0.0, 1.0)).w;\n  \tform.z = getFormAt(p + vec2(1.0, 0.0)).x;\n  \tform.w = getFormAt(p + vec2(0.0, -1.0)).y;\n\n  \ttrackValue = ontrack(vec2(mod(p.x, 1.0), mod(p.y, 1.0)), form);\n  }\n  trackValue = trackValue * 2.0;\n  trackValue += (log(depth) / 1.5);\n  gl_FragColor = vec4(trackValue - 1.5, trackValue - 1.5, trackValue, 0.0);\n}\n\n\n\n\n"
    },
    {
      "name": "Red vs Cyan",
      "date": "2024-09-22",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform int powerConnected;\nuniform float battery;\nconst float pi = 3.14159265359;\n\nconst float scale = 1000.0;\nconst int octaves = 3;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvoid main(void) {\n\tfloat pV = perlin3d(vec3(gl_FragCoord.xy, time * 50.0 ));\n\tvec3 color = vec3(sin(pV), sin(pV + pi), sin(pV + pi));\n\n\tgl_FragColor = vec4(color * mod(pV * 10.0, 1.0), 1.0);\n}\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Layers",
      "date": "2024-09-22",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nconst float pi = 3.14159265359;\n\nconst float scale = 400.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nfloat normSin(float i) {\n\treturn sin(i)/2.0+0.5;\n}\n\nvec4 colorMix(float hue) {\n\treturn vec4(normSin(hue), normSin(hue + pi * 2.0/3.0), normSin(hue + pi * 4.0/3.0), 1.0);\n}\n\nvoid main(void) {\n\tfloat plateaus = 14.0;\n\tvec3 pos = vec3(gl_FragCoord.xy, time * scale / 10.0);\n\tfloat pV = perlin3d(pos) * plateaus;\n\tfloat cV = floor(pV)/5.0 + 2.5;\n\tfloat a = 0.0;\n\tfloat m = mod(pV, 1.0);\n\tif(m > 0.9) {\n\t\ta = perlin3d(pos + vec3(0.005, 0.01, 0.0)) * plateaus - pV;\n\t} else if(m < 0.1) {\n\t\ta = perlin3d(pos + vec3(0.005, 0.01, 0.0)) * plateaus - pV;\n\t\ta = min(a, 0.0) * 10.0 *(0.1-m);\n\t}\n\n\tgl_FragColor = vec4(colorMix(cV)) + a * 2000.0;\n}\n\n\n\n\n"
    },
    {
      "name": "Flows",
      "date": "2024-09-26",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 100.0;\nconst float scale = 10.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\nconst float pi = 3.14159265;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tvec2 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 4; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex), 2.0), floor(float(vertex) / 2.0));\n      float gradAngle = 2.0 * pi * rand(floor(pos/cScale) + vertexOffset);\n      vec2 g = vec2(sin(gradAngle), cos(gradAngle));\n      vec2 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(sin(b) * v.x + cos(b) * v.y, cos(b) * v.x - sin(b) * v.y);\n}\n\nvoid main(void) {\n\tvec2 pos = gl_FragCoord.xy/size;\n\tvec2 vertex = floor(pos + vec2(0.5));\n\tfloat dis = distance(vertex, pos);\n\tfloat pV = perlin(rotateVec(pos, time*10.0) + vec2(time)) * 3.0;\n\tint cV = int(clamp(pV * dis * 8.0 + 2.0, 0.0, 3.0));\n\n\tvec3 color;\n\tif(cV == 0) color = vec3(0.0, 0.0, 0.0);\n\telse if(cV == 1) color = vec3(1.0, 0.2, 0.0);\n\telse if(cV == 2) color = vec3(0.0, 0.9, 1.0);\n\telse color = vec3(1.0, 1.0, 1.0);\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n\n\n\n"
    },
    {
      "name": "Trippy Dots",
      "date": "2024-10-08",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float cellSize = 100.0;\nconst float frequency = 1.0;\nconst float colorOffset = 0.1;\n\nfloat round(float v){return floor(v + 0.5);}\nvec2 round(vec2 v){return vec2(round(v.x), round(v.y));}\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(sin(b) * v.x + cos(b) * v.y, cos(b) * v.x - sin(b) * v.y);\n}\n\nvoid main(void) {\n\tfloat t = sin(time)*2.0;\n\tvec2 coord = rotateVec((gl_FragCoord.xy - resolution/2.0) / cellSize, 10.0 * time);\n\tvec2 cell = round(coord);\n\tfloat cellDist = length(cell);\n\tfloat cellB1 = sin(cellDist/frequency * t) + 1.3;\n\tfloat cellB2 = sin(cellDist/frequency * t + colorOffset) + 1.3;\n\n\tfloat fragDist = distance(cell, coord) * 1.414;\n\n\tfloat step1 = step(cellB1, fragDist);\n\tfloat step2 = step(cellB2, fragDist);\n\n\n\tgl_FragColor = vec4(step1, step2, step2, 1.0);\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Earth",
      "date": "2024-10-11",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D world1;\nuniform sampler2D world2;\n\nconst float pi = 3.14159;\nconst float radius = 500.0;\nconst float sun = -100.0;\nconst float fov = 0.0;\nconst vec4 atmosphere = vec4(0.2, 0.5, 1.0, 1.0) * 0.4;\nconst float sunSpeed = 1.0;\nconst float earthSpeed = 0.1;\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat getAngle(vec2 c) {\n\tfloat angle = atan(c.y / c.x) + pi/2.0;\n  if(c.x < 0.0) angle += + pi;\n\treturn angle;\n}\n\nvoid main(void) {\n\tvec2 center = resolution/2.0;\n\tvec2 coord = (gl_FragCoord.xy - center) / radius;\n\tvec2 rotatedCoord = rotateVec(coord, -23.5);\n\n\tfloat dist = length(coord);\n\tfloat f = getAngle(coord);\n\tfloat sunRadian = mod(sun / 180.0 * pi + time * sunSpeed + pi, 2.0 * pi) - pi;\n\n\n\tif(dist > 1.0) {\n\t\t//is atmosphere or space\n\t\tfloat sunFactor = sin(f) * -sin(sunRadian) + cos(sunRadian) * 0.4;\n\t  gl_FragColor = atmosphere * 3.0 * sunFactor * clamp(1.0 - (dist - 1.0) * 18.0, 0.0, 1.0);\n\t} else {\n\t\tfloat d = asin(dist) * (180.0 - fov) / 180.0;\n\t\tfloat e = getAngle(rotatedCoord);\n\n\t\tfloat latitude = asin(sin(d) * cos(e));\n\t\tfloat longitude = mod(atan(tan(d) * sin(e)) + time * earthSpeed, 2.0 * pi);\n\n\t\tfloat sunLat = asin(sin(d) * cos(f));\n\t\tfloat sunLong = atan(tan(d) * sin(f)) + sunRadian;\n\t\tsunLong = mod(sunLong + pi, 2.0 * pi) - pi;\n\n\t\tvec3 sampleVec;\n\t\tfloat x = longitude/pi;\n\t\tfloat y = -sin(latitude) / 2.3 + 0.5;\n    if (longitude <= pi) sampleVec = texture2D(world1, vec2(x, y)).rgb;\n    else sampleVec = texture2D(world2, vec2(x - 1.0, y)).rgb;\n\n    float diffuse = cos(sunLong) * cos(sunLat) * 1.5;\n\n    vec2 specCenter = vec2(sunRadian / 2.0, 0.0);\n    float specDist = distance(specCenter, vec2(sunLong, sunLat));\n    vec4 specular = vec4(0.0);\n\n    float blueThresh = sampleVec.z - (sampleVec.x + sampleVec.y) * 0.5;\n\n    if(blueThresh > 0.0) specular = vec4(1.0, 0.9, 0.5, 1.0) * 0.7 * clamp(0.035 / specDist - 0.1, 0.0, 1.0);\n\n\t\tgl_FragColor = (vec4(sampleVec, 1.0) + atmosphere) * diffuse + specular;\n\t}\n}\n\n\n\n"
    }



  ]
}