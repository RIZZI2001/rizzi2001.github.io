{
  "shaders": [
    {
      "name": "Bricks",
      "date": "2024-09-13",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nvoid main(void) {\n    vec4 a[6];\n    a[0] = vec4(1.0, 0.4, 0.4, 1.0);\n    a[1] = vec4(0.4, 1.0, 0.4, 1.0);\n    a[2] = vec4(0.9, 0.9, 0.4, 1.0);\n    a[5] = vec4(0.7, 0.5, 1.0, 1.0);\n    a[4] = vec4(0.3, 0.9, 0.9, 1.0);\n    a[3] = vec4(1.0, 0.6, 0.4, 1.0);\n\n    vec2 uv = gl_FragCoord.xy / resolution.xx;\n    float xColumn = floor(uv.x * 10.0 - time);\n    float offset = 6.0 * xColumn;\n    float yColumn = floor((uv.y * 10.0 + time + xColumn)/2.0 + offset);\n    float xBorder = step(0.2, mod(uv.x * 10.0 - time, 1.0));\n    float yBorder = step(0.2, mod(uv.y * 10.0 + time + xColumn, 2.0));\n    int colorIndex = int(mod(xColumn + yColumn, 6.0));\n\n    gl_FragColor = xBorder * yBorder *\n      vec4(1.0, 0.4, 0.2, 1.0) * mod(float(colorIndex + 1)/6.0 * gl_FragCoord.x/200.0, 1.0);\n      //a[colorIndex];\n}\n"
    },
    {
      "name": "Leaves",
      "date": "2024-09-14",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\nfloat noisey(vec2 n) {return rand(floor(n)); }\n\nvoid main(void) {\n\tfloat zoom = 100.0;\n\n\tfloat angle = 0.4;\n\tvec2 t_coord = vec2(\n\t\t(sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y),\n\t  (sin(angle) * gl_FragCoord.y - cos(angle) * gl_FragCoord.x) + time * 100.0\n\t\t)/zoom;\n\n\tfloat noise_val = noisey(t_coord);\n\tvec2 origin = floor(t_coord);\n\n\torigin = origin + vec2(1.0, 0.0) * step(noise_val, 0.5);\n\torigin = origin + vec2(0.0, 1.0) * step(mod(noise_val, 0.5), 0.25);\n\n\tfloat dist = distance(origin, t_coord);\n\n\tfloat shadow_val = clamp(mod((1.0 - t_coord.x)*2.0, 2.0) + 0.3, 0.0, 1.0);\n\n\tnoise_val = mod(noise_val, 0.25)*4.0;\n\n\tfloat desx = step(noise_val, 0.95);\n\tfloat variance = (1.0 - noise_val)*15.0;\n\tvec4 col =\n\t\tvec4(noise_val*0.5, noise_val, 0.0, 1.0) * desx +\n\t\tvec4(1.0, 0.7 - variance, variance, 1.0) * (1.0 - desx);\n\n\tgl_FragColor = col * step(dist, 1.0) * shadow_val;\n}\n"
    },
    {
      "name": "Lava Lamp",
      "date": "2024-09-19",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float pi = 3.14159265;\nconst int amount = 40;\n\nfloat pointDistance(vec3 pos) {\n\treturn pow(clamp(1.0 - length((gl_FragCoord.xy - pos.xy) / pos.z), 0.0, 1.0), 2.0);\n}\n\nvoid main(void) {\n\t\n  float t = time/2.0 + 20.0;\n  float brightness = 0.0;\n  float size = 140.0;\n\n\tfor(int i = 0; i < amount; i ++) {\n\t\tfloat n = float(i) / float(amount);\n\t\tfloat x = mod(200.0 * t * sin(2.0 * pi * n+ 0.15), resolution.x*1.4) - resolution.x * 0.2;\n\t\tfloat y = mod(200.0 * t * cos(2.0 * pi * n), resolution.y*1.4) - resolution.y * 0.2;\n\t\tif(distance(vec2(x, y), gl_FragCoord.xy) > 3.0 * size) continue;\n\t\tfloat s = size * (2.0 + cos(2.0 * pi * n));\n\t\tfloat d = pointDistance(vec3(x, y, s));\n\t  brightness += d;\n\t\tif (brightness >= 1.0) break;\n\t}\n\tgl_FragColor = vec4(0.8, 0.8, 0.0, 1.0) * (step(0.5, brightness) + brightness*1.5) + vec4(0.5, 0.0, 0.5, 1.0);\n}"    
    },
    {
      "name": "Fibonnacci",
      "date": "2024-09-19",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat inCircle(float n, float o, float r) {\n\tfloat angle = 2.4 * n + time/10.0;\n\tvec2 circle = resolution/2.0 + sqrt(n) * o * vec2(sin(angle), cos(angle));\n\treturn distance(gl_FragCoord.xy, circle);\n}\n\nvoid main(void) {\n    vec2 center = resolution / 2.0;\n    gl_FragColor = vec4(0.0, 0.4, 0.0, 1.0);\n\n    float amount = 200.0;\n    float t_amount = mod(floor(time*30.0), amount * 2.0);\n    t_amount += step(amount, t_amount) * 2.0 * (amount - t_amount);\n\n    float o = 55.0;\n    float r = 80.0;\n    float d = distance(gl_FragCoord.xy, center);\n\n    float mini = floor(max(pow((d-r)/o, 2.0)-1.0,0.0));\n    float maxi = ceil(min(pow((d+r)/o, 2.0),t_amount));\n\n    const int MAX_ITER = 300; // must be >= possible maxi\n    for(int i = 0; i < MAX_ITER; i++) {\n        if(float(i) < mini) continue;\n        if(float(i) >= maxi) break;\n        float a = inCircle(float(i), o, r)/r;\n        float b = float(i)/amount/2.0+0.5;\n        if(a < 1.0) {\n            gl_FragColor = vec4(1.0, 1.0-b, b, 1.0) * (0.9 + a);\n            break;\n        }\n    }\n}\n"
    },
    {
      "name": "Symbol Landscape",
      "date": "2024-09-21",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 20.0;\nconst float angle = 0.5;\nconst vec4 color = vec4(1.0, 0.0, 0.7, 1.0);\n\nconst float pi = 3.14159265335;\nconst float scale = 100.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tfloat a; float b;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 1; vertex < 5; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex + 1), 2.0), floor(float(vertex) / 3.0));\n      float gradAngle = 2.0 * pi * rand(floor(vec2(pos/cScale)) + vertexOffset);\n      float gradX = sin(gradAngle);\n      float gradY = cos(gradAngle);\n      float oX = floor(pos.x/cScale) + float((mod(float(vertex), 2.0) == 0.0));\n      float oY = floor(pos.y/cScale) + float(vertex > 2);\n      oX = (pos.x - oX * cScale) / cScale;\n      oY = (pos.y - oY * cScale) / cScale;\n      if(vertex == 1) {\n      \ta = pow(oX, 3.0) * (oX * (oX * 6.0 - 15.0) + 10.0);\n      \tb = pow(oY, 3.0) * (oY * (oY * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex - 1] = gradX * oX + gradY * oY;\n\t\t}\n\t\tlayeredPV += cAmplitude * ((1.0 - b) * ((1.0 - a) * cV[0] + a * cV[1]) + b * ((1.0 - a) * cV[2] + a * cV[3]));\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nfloat ontrack(vec2 uv, vec4 p) {\n\tfloat type;\n\tvec2 corner;\n\tif(p == vec4(0.0)) return 0.0;\n\tif(length(p) == 1.0){\n\t\ttype = 0.0;\n\t\tif (p.x == 1.0) corner = vec2(1.0, 0.0);\n\t\tif (p.y == 1.0) corner = vec2(1.0, 1.0);\n\t\tif (p.z == 1.0) corner = vec2(0.0, 1.0);\n\t\tif (p.w == 1.0) corner = vec2(0.0, 0.0);\n\t} else if (length(p) == length(vec2(1.0))) {\n\t\tif(p == vec4(1.0, 0.0, 1.0, 0.0)) {type = 1.0; corner = vec2(0.0, 1.0);}\n\t\telse if(p == vec4(0.0, 1.0, 0.0, 1.0)) {type = 1.0; corner = vec2(0.0, 0.0);}\n\t\telse {\n\t\t\ttype = 2.0;\n\t\t\tif(p.x == 1.0) {\n\t\t\t\tif(p.y == 1.0) {\n\t\t\t\t\tcorner = vec2(1.0, 0.0);\n\t\t\t\t} else {\n\t\t\t\t\tcorner = vec2(0.0, 0.0);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(p.y == 1.0) {\n\t\t\t\t\tcorner = vec2(1.0, 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tcorner = vec2(0.0, 1.0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if(length(p) == length(vec3(1.0))) {\n\t\ttype = 3.0;\n\t\tif (p.x == 0.0) corner = vec2(0.0, 0.0);\n\t\tif (p.y == 0.0) corner = vec2(1.0, 0.0);\n\t\tif (p.z == 0.0) corner = vec2(1.0, 1.0);\n\t\tif (p.w == 0.0) corner = vec2(0.0, 1.0);\n\t} else {\n\t\ttype = 4.0;\n\t}\n\tfloat sv = mod(corner.x + corner.y, 2.0);\n  vec2 r_uv = (uv.xy * (1.0 - sv) + uv.yx * sv) * (-2.0 * corner + vec2(1.0)) + corner;\n\tif(type == 0.0) {\n\t\tif(r_uv.y < 0.5) return 1.0 - distance(r_uv.x, 0.5) * 2.0;\n\t\telse return max(1.0 - distance(r_uv, vec2(0.5)) * 2.0, 0.0);\n\t} else if (type == 1.0) {\n  \treturn 1.0 - distance(r_uv.x, 0.5) * 2.0;\n  } else if(type == 2.0) {\n    float dist = distance(r_uv, vec2(0.0)) * 2.0;\n    dist += 2.0 * (step(1.0, dist) * -dist + step(1.0, dist));\n    return max(dist, 0.0);\n  } else if (type == 3.0) {\n  \tif(r_uv.x < 0.5) return 1.0 - distance(r_uv.x, 0.5) * 2.0;\n  \telse return 1.0 - min(distance(r_uv.x, 0.5), distance(r_uv.y, 0.5)) * 2.0;\n  } else {\n  \treturn 1.0 - min(distance(r_uv.x, 0.5), distance(r_uv.y, 0.5)) * 2.0;\n  }\n}\n\nvec4 getFormAt(vec2 pos) {\n\tfloat aV = clamp(perlin(floor(pos)) * 0.6 + 0.8, 0.0, 1.0);\n\tfloat r = rand(floor(pos));\n\tvec4 outputs = vec4(0.0);\n\tif(mod(r,1.0) > aV) outputs.x = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.y = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.z = 1.0; r = mod(r * 2.0, 1.0);\n\tif(mod(r,1.0) > aV) outputs.w = 1.0; r = mod(r * 2.0, 1.0);\n  return outputs;\n}\n\nvoid main(void) {\n\tfloat depth = max((resolution.y/1.5 - gl_FragCoord.y) / 1000.0, 0.0);\n\tvec2 p = gl_FragCoord.xy / depth + vec2(-100.0, 300.0) * time;\n\tp = vec2(sin(angle) * p.x + cos(angle) * p.y, sin(angle) * p.y - cos(angle) * p.x)/size;\n\n  float trackValue;\n\n\tif(mod(floor(p.x) + floor(p.y), 2.0) == 1.0) {\n\t  trackValue = ontrack(vec2(mod(p.x, 1.0), mod(p.y, 1.0)), getFormAt(p));\n  } else {\n  \tvec4 form = vec4(0.0);\n\n  \tform.x = getFormAt(p + vec2(-1.0, 0.0)).z;\n  \tform.y = getFormAt(p + vec2(0.0, 1.0)).w;\n  \tform.z = getFormAt(p + vec2(1.0, 0.0)).x;\n  \tform.w = getFormAt(p + vec2(0.0, -1.0)).y;\n\n  \ttrackValue = ontrack(vec2(mod(p.x, 1.0), mod(p.y, 1.0)), form);\n  }\n  trackValue = trackValue * 2.0;\n  trackValue += (log(depth) / 1.5);\n  gl_FragColor = vec4(trackValue - 1.5, trackValue - 1.5, trackValue, 0.0);\n}\n\n\n\n\n"
    },
    {
      "name": "Red vs Cyan",
      "date": "2024-09-22",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform int powerConnected;\nuniform float battery;\nconst float pi = 3.14159265359;\n\nconst float scale = 1000.0;\nconst int octaves = 3;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvoid main(void) {\n\tfloat pV = perlin3d(vec3(gl_FragCoord.xy, time * 50.0 ));\n\tvec3 color = vec3(sin(pV), sin(pV + pi), sin(pV + pi));\n\n\tgl_FragColor = vec4(color * mod(pV * 10.0, 1.0), 1.0);\n}\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Layers",
      "date": "2024-09-22",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nconst float pi = 3.14159265359;\n\nconst float scale = 400.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nfloat normSin(float i) {\n\treturn sin(i)/2.0+0.5;\n}\n\nvec4 colorMix(float hue) {\n\treturn vec4(normSin(hue), normSin(hue + pi * 2.0/3.0), normSin(hue + pi * 4.0/3.0), 1.0);\n}\n\nvoid main(void) {\n\tfloat plateaus = 14.0;\n\tvec3 pos = vec3(gl_FragCoord.xy, time * scale / 10.0);\n\tfloat pV = perlin3d(pos) * plateaus;\n\tfloat cV = floor(pV)/5.0 + 2.5;\n\tfloat a = 0.0;\n\tfloat m = mod(pV, 1.0);\n\tif(m > 0.9) {\n\t\ta = perlin3d(pos + vec3(0.005, 0.01, 0.0)) * plateaus - pV;\n\t} else if(m < 0.1) {\n\t\ta = perlin3d(pos + vec3(0.005, 0.01, 0.0)) * plateaus - pV;\n\t\ta = min(a, 0.0) * 10.0 *(0.1-m);\n\t}\n\n\tgl_FragColor = vec4(colorMix(cV)) + a * 2000.0;\n}\n\n\n\n\n"
    },
    {
      "name": "Flows",
      "date": "2024-09-26",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 100.0;\nconst float scale = 10.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\nconst float pi = 3.14159265;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tvec2 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 4; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex), 2.0), floor(float(vertex) / 2.0));\n      float gradAngle = 2.0 * pi * rand(floor(pos/cScale) + vertexOffset);\n      vec2 g = vec2(sin(gradAngle), cos(gradAngle));\n      vec2 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(sin(b) * v.x + cos(b) * v.y, cos(b) * v.x - sin(b) * v.y);\n}\n\nvoid main(void) {\n\tvec2 pos = gl_FragCoord.xy/size;\n\tvec2 vertex = floor(pos + vec2(0.5));\n\tfloat dis = distance(vertex, pos);\n\tfloat pV = perlin(rotateVec(pos, time*10.0) + vec2(time)) * 3.0;\n\tint cV = int(clamp(pV * dis * 8.0 + 2.0, 0.0, 3.0));\n\n\tvec3 color;\n\tif(cV == 0) color = vec3(0.0, 0.0, 0.0);\n\telse if(cV == 1) color = vec3(1.0, 0.2, 0.0);\n\telse if(cV == 2) color = vec3(0.0, 0.9, 1.0);\n\telse color = vec3(1.0, 1.0, 1.0);\n\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n\n\n\n"
    },
    {
      "name": "Trippy Dots",
      "date": "2024-10-08",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float cellSize = 100.0;\nconst float frequency = 1.0;\nconst float colorOffset = 0.1;\n\nfloat round(float v){return floor(v + 0.5);}\nvec2 round(vec2 v){return vec2(round(v.x), round(v.y));}\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(sin(b) * v.x + cos(b) * v.y, cos(b) * v.x - sin(b) * v.y);\n}\n\nvoid main(void) {\n\tfloat t = sin(time)*2.0;\n\tvec2 coord = rotateVec((gl_FragCoord.xy - resolution/2.0) / cellSize, 10.0 * time);\n\tvec2 cell = round(coord);\n\tfloat cellDist = length(cell);\n\tfloat cellB1 = sin(cellDist/frequency * t) + 1.3;\n\tfloat cellB2 = sin(cellDist/frequency * t + colorOffset) + 1.3;\n\n\tfloat fragDist = distance(cell, coord) * 1.414;\n\n\tfloat step1 = step(cellB1, fragDist);\n\tfloat step2 = step(cellB2, fragDist);\n\n\n\tgl_FragColor = vec4(step1, step2, step2, 1.0);\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Earth",
      "date": "2024-10-11",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D world1;\nuniform sampler2D world2;\n\nconst float pi = 3.14159;\nconst float radius = 500.0;\nconst float sun = -100.0;\nconst float fov = 0.0;\nconst vec4 atmosphere = vec4(0.2, 0.5, 1.0, 1.0) * 0.4;\nconst float sunSpeed = 1.0;\nconst float earthSpeed = 0.1;\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat getAngle(vec2 c) {\n\tfloat angle = atan(c.y / c.x) + pi/2.0;\n  if(c.x < 0.0) angle += + pi;\n\treturn angle;\n}\n\nvoid main(void) {\n\tvec2 center = resolution/2.0;\n\tvec2 coord = (gl_FragCoord.xy - center) / radius;\n\tvec2 rotatedCoord = rotateVec(coord, -23.5);\n\n\tfloat dist = length(coord);\n\tfloat f = getAngle(coord);\n\tfloat sunRadian = mod(sun / 180.0 * pi + time * sunSpeed + pi, 2.0 * pi) - pi;\n\n\n\tif(dist > 1.0) {\n\t\t//is atmosphere or space\n\t\tfloat sunFactor = sin(f) * -sin(sunRadian) + cos(sunRadian) * 0.4;\n\t  gl_FragColor = atmosphere * 3.0 * sunFactor * clamp(1.0 - (dist - 1.0) * 18.0, 0.0, 1.0);\n\t} else {\n\t\tfloat d = asin(dist) * (180.0 - fov) / 180.0;\n\t\tfloat e = getAngle(rotatedCoord);\n\n\t\tfloat latitude = asin(sin(d) * cos(e));\n\t\tfloat longitude = mod(atan(tan(d) * sin(e)) + time * earthSpeed, 2.0 * pi);\n\n\t\tfloat sunLat = asin(sin(d) * cos(f));\n\t\tfloat sunLong = atan(tan(d) * sin(f)) + sunRadian;\n\t\tsunLong = mod(sunLong + pi, 2.0 * pi) - pi;\n\n\t\tvec3 sampleVec;\n\t\tfloat x = longitude/pi;\n\t\tfloat y = -sin(latitude) / 2.3 + 0.5;\n    if (longitude <= pi) sampleVec = texture2D(world1, vec2(x, y)).rgb;\n    else sampleVec = texture2D(world2, vec2(x - 1.0, y)).rgb;\n\n    float diffuse = cos(sunLong) * cos(sunLat) * 1.5;\n\n    vec2 specCenter = vec2(sunRadian / 2.0, 0.0);\n    float specDist = distance(specCenter, vec2(sunLong, sunLat));\n    vec4 specular = vec4(0.0);\n\n    float blueThresh = sampleVec.z - (sampleVec.x + sampleVec.y) * 0.5;\n\n    if(blueThresh > 0.0) specular = vec4(1.0, 0.9, 0.5, 1.0) * 0.7 * clamp(0.035 / specDist - 0.1, 0.0, 1.0);\n\n\t\tgl_FragColor = (vec4(sampleVec, 1.0) + atmosphere) * diffuse + specular;\n\t}\n}\n\n\n\n"
    },
    {
    "name": "Voronoi",
    "date": "2024-10-12",
    "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float pi = 3.14159265;\nconst int amount = 30;\n\nfloat bounce(float value, float period) {\n\tfloat r = mod(value, 2.0 * period);\n\treturn period -abs(period - r);\n}\n\nvoid main(void) {\n\n\tvec2 center = resolution/2.0;\n\tfloat minDist = 10000.0;\n\tfloat ccv;\n\tfor(int i = 0; i < amount; i ++) {\n\t\tfloat value = float(i)/float(amount);\n\t\tfloat vertexAngle = value * 0.5 * pi;\n\t\tfloat t = time * 100.0 + 20000.0;\n\t\tvec2 vertexpos = vec2(bounce(sin(vertexAngle) * t + center.x, resolution.x), bounce(cos(vertexAngle) * t + center.y, resolution.y));\n\t\tvalue = vertexpos.x/resolution.x + vertexpos.y/resolution.y;\n\t\tfloat dist = distance(gl_FragCoord.xy, vertexpos);\n\t\tif(dist < minDist) {\n\t\t\tminDist = dist;\n\t\t\tccv = value;\n\t\t}\n\t}\n\tfloat intervals = 3.0;\n\tccv = bounce(ccv*intervals, 1.0) * 0.5 + 0.25;\n\tgl_FragColor = vec4(ccv, 0.0, 1.0-ccv, 1.0);\n\t//gl_FragColor = vec4(0.0, 1.0 - minDist/ 300.0, 1.0, 1.0);\n}\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Landscape",
      "date": "2024-10-13",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float camHeight = 40.0;\nconst float duneHeight = 30.0;\n\nconst float pi = 3.14159265359;\n\nconst float lacunarity = 0.5;\nconst float persistance = 0.5;\n\nvec2 rotateVec(vec2 v, float b) {\n    return vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat noize(vec2 pos) {\n    return mix(\n        mix(rand(floor(pos)), rand(vec2(ceil(pos.x), floor(pos.y))), fract(pos.x)),\n        mix(rand(vec2(floor(pos.x), ceil(pos.y))), rand(ceil(pos)), fract(pos.x)),\n        fract(pos.y)\n    );\n}\n\nfloat layeredNoize(vec2 pos, int octaves, float scale) {\n    pos = pos/scale;\n    float layered = 0.0;\n    const int MAX_OCTAVES = 10;\n    for(int layer = 1; layer <= MAX_OCTAVES; layer++) {\n        if(layer > octaves) break;\n        pos = rotateVec(pos/lacunarity, 2.4);\n        layered += noize(pos) * pow(persistance, float(layer));\n    }\n    return layered;\n}\n\nvec3 getColor(float height) {\n    if(height > 0.7) return vec3(0.8, 0.8, 0.8);\n    if(height > 0.65) return vec3(0.55, 0.5, 0.4);\n    height /= 0.65;\n    return vec3(0.8-height, 0.6, height* 0.1);\n}\n\nvoid main(void) {\n    vec2 center = resolution * 0.5;\n    float maxi = max(center.x, center.y);\n    vec2 sightVec = (gl_FragCoord.xy - center)/maxi - vec2(0.0, 0.0);\n\n    float zIntersec = (camHeight-duneHeight)/-sightVec.y;\n    if(zIntersec <= 0.0) {\n        gl_FragColor = vec4(0.4, 0.6, 1.0, 1.0);\n    } else {\n        float t = time * 10.0;\n        vec3 samplePos = vec3(0.0, camHeight, 0.0);\n        float sampleHeight = 0.0;\n\n        const int MAX_STEPS = 20;\n        for(int counter = 0; counter < MAX_STEPS; counter++) {\n            samplePos = vec3(sightVec.x * zIntersec, camHeight + sightVec.y * zIntersec, zIntersec + t);\n            sampleHeight = layeredNoize(samplePos.xz, 7, 50.0) * duneHeight;\n            if(abs(samplePos.y - sampleHeight) <= 0.2) break;\n            zIntersec += (samplePos.y - sampleHeight) * sqrt(zIntersec/50.0);\n        }\n\n        float sampleOffset = layeredNoize(samplePos.xz + vec2(0.001, -0.0005), 7, 50.0) * duneHeight;\n        float difference = (sampleHeight - sampleOffset)*200.0;\n        float rnd = 0.5 * (layeredNoize(samplePos.xy + vec2(200.0, 300.0), 2, 50.0) - 0.5);\n\n        gl_FragColor = vec4(getColor(sampleHeight/ duneHeight + rnd), 1.0) * ((difference + 0.8) * (sampleHeight/duneHeight + 0.1));\n    }\n}"
    },
    {
      "name": "Glitchy Hexagons",
      "date": "2024-10-17",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 200.0;\n\nvec2 rotateVec(vec2 v, float a) {\n\tfloat b = -a / 180.0 * 3.1415926;\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec3 hexHeight(vec2 coord) {\n\tcoord.y /= 0.8660254;\n\tcoord.x  = coord.x - 0.5 * coord.y;\n\tvec2 cellCoord = floor(coord);\n\tint cellType = int(mod(cellCoord.x - cellCoord.y, 3.0));\n\tvec2 iCC = mod(coord, 1.0);\n\tint halfIndex = int(step(1.0, iCC.x + iCC.y));\n\tfloat height;\n\tvec2 center;\n\tif(cellType == 0){\n\t\tcenter = cellCoord + vec2(1.0, 0.0);\n\t\tif(halfIndex == 0) {\n\t\t\theight = iCC.x;\n\t\t} else {\n\t\t\theight = 1.0 - iCC.y;\n\t  }\n\t} else if(cellType == 1) {\n\t\tif(halfIndex == 0) {\n\t\t\tcenter = cellCoord;\n\t\t\theight = 1.0 - iCC.x - iCC.y;\n\t\t} else {\n\t\t\tcenter = cellCoord + vec2(1.0, 1.0);\n\t\t\theight = iCC.x + iCC.y - 1.0;\n\t\t}\n\t} else {\n\t\tcenter = cellCoord + vec2(0.0, 1.0);\n\t\tif(halfIndex == 0) {\n\t\t\theight = iCC.y;\n\t\t} else {\n\t\t\theight = 1.0 - iCC.x;\n\t\t}\n\t}\n\treturn vec3(height, center);\n}\n\nfloat getBrightness(vec2 pos, vec2 offset){\n\tvec3 h = hexHeight(rotateVec((pos + time) / size, time) + offset);\n\tfloat b = rand(h.yz) * 0.5 + 0.7;\n\tfloat a = step(3.0 * sin(time/4.0 + b * 1000.0) - 2.0, h.x);\n\treturn 1.0 - a*b;\n}\n\nfloat getLayeredBrightness(vec2 pos) {\n\tfloat brightness = getBrightness(pos, vec2(0.0));\n\tfor(int i = 1; i <= 12; i ++) {\n\t\tfloat factor = 0.4/float(i);\n\t\tvec2 dir = vec2(mod(float(i), 2.0), mod(float(i+1), 2.0)) * (mod(floor(float(i)/2.0), 2.0) * 2.0 - 1.0);\n\t\tvec2 offset = vec2(floor(float(i+3)/4.0) * size + 1.0) * dir;\n\t\tbrightness += factor * clamp(getBrightness(pos, offset) - 0.2, 0.0, 1.0);\n\t}\n\treturn brightness;\n}\n\nvec2 glitchFilter(vec2 pos, float seed) {\n\tfloat r = rand(vec2(floor(time*10.0), floor(pos.y/ 60.0)));\n\tif(r <= 0.1) pos.x += 300.0 * r * seed;\n  return pos;\n}\n\nvec4 getColor(vec2 pos) {\n\tfloat red = getLayeredBrightness(glitchFilter(pos, 1.0));\n\tfloat cyan = getLayeredBrightness(glitchFilter(pos, 1.4));\n\treturn vec4(red, cyan, cyan, 1.0);\n}\n\nvec4 pixelize(vec2 pos, float size) {\n\tvec4 color = getColor(floor(pos / size) * size);\n\tpos = fract(pos / size);\n\tfloat yFac = step(pos.y, 0.9);\n\tfloat xFac = step(fract(pos.x * 3.0), 0.7);\n\tfloat rgb = floor(pos.x * 3.0);\n\tvec3 rgbFac = vec3((rgb == 0.0), (rgb == 1.0), (rgb == 2.0));\n\treturn color * vec4(rgbFac, 1.0) * yFac * xFac;\n}\n\nvoid main(void) {\n\tgl_FragColor = pixelize(gl_FragCoord.xy, 9.0);\n}\n\n\n\n\n\n"
    },
    {
      "name": "Triangle Gradient",
      "date": "2024-10-29",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec4 interpolateColors(float v) {\n\treturn\n\tstep(abs(v - 0.5), 0.5) * vec4(53, 80, 112, 1.0) +\n\tstep(abs(v - 1.5), 0.5) * vec4(109, 89, 122, 1.0) +\n\tstep(abs(v - 2.5), 0.5) * vec4(181, 101, 118, 1.0) +\n\tstep(abs(v - 3.5), 0.5) * vec4(229, 117, 111, 1.0) +\n\tstep(abs(v - 4.5), 0.5) * vec4(234, 172, 139, 1.0);\n}\n\nvec3 triHeight(vec2 coord) {\n\tcoord.y /= 0.8660254;\n\tcoord.x  = coord.x - 0.5 * coord.y;\n\tvec2 cellCoord = floor(coord) * vec2(2.0, 1.0);\n\tcellCoord += vec2(cellCoord.y, 0.0);\n\tvec2 iCC = mod(coord, 1.0);\n\tif(step(1.0, iCC.x + iCC.y) == 1.0) {\n\t\tiCC = 1.0 - iCC;\n\t\tcellCoord += vec2(1.0, 0.0);\n\t}\n\tfloat height;\n\tvec2 ab = vec2(min(iCC.x, iCC.y), max(iCC.x, iCC.y));\n\tif(2.0 * ab.x + ab.y > 1.0) return vec3(3.0 * (1.0 - (ab.x + ab.y)), cellCoord);\n\telse return vec3(3.0 * ab.x, cellCoord);\n}\n\nvoid main(void) {\n\tfloat t = time/3.0;\n\tvec3 tH = triHeight(gl_FragCoord.xy/200.0);\n\tfloat value = mod((tH.x + t - tH.y/20.0) * 1.5, 5.0);\n\tgl_FragColor = interpolateColors(value) / 255.0;\n}\n\n\n\n\n\n"
    },
    {
      "name": "Sierpinsky",
      "date": "2024-11-04",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nbool inSierpinsky(vec2 pos, float t) {\n    const int maxSteps = 32;\n    int limit = int(11.0 + t * 4.0);\n    int counter = 0;\n    for(int i = 0; i < maxSteps; i++) {\n        if(!(pos.x + pos.y < 1.0 && counter < limit)) break;\n        pos = mod(pos * 2.0, 1.0);\n        counter++;\n    }\n    return (pos.x + pos.y < 1.0);\n}\n\nfloat timedSierpinsky(vec2 pos, float t) {\n\tfloat maxi = max(resolution.x, resolution.y);\n\tpos = (pos - resolution/2.0) / maxi / 2.0;\n\tpos /= pow(2.0, t * 4.0);\n\tpos = rotateVec(pos, t * 2.0943951);\n\tpos.x *= 0.8660254;\n\tpos += 1.142857143 * vec2(1.0, 1.0)/2.0;\n\tpos.x -= pos.y * 0.5;\n\treturn float(inSierpinsky(pos, t));\n}\n\nvoid main(void) {\n\tvec2 pos = gl_FragCoord.xy;\n\tfloat t = mod(time / 10.0, 1.0);\n\n\tfloat sum = timedSierpinsky(pos, t);\n\n\tgl_FragColor = vec4(sum) * (1.0 - 0.1 * mod(t*4.0, 1.0));\n}\n\n\n\n\n\n"
    },
    {
      "name": "Blazing Fractal",
      "date": "2024-11-06",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec2 rotateVec(vec2 v, float b) {\n    return vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvec4 get(vec2 coord) {\n    return texture2D(backbuffer, coord/resolution);\n}\n\nbool getFractal(vec2 pos, float t, vec4 modify){\n    const int MAX_ITER = 100;\n    int limit = int(12.0 + t * 8.0);\n    for(int i = 0; i < MAX_ITER; i ++) {\n        if(i >= limit) break;\n        pos *= 2.0;\n        if(pos.x < 1.0){\n            if(pos.y < 1.0){\n                return false;\n            } else {\n                pos = vec2(mod(pos.y, 1.0), mod(-pos.x, 1.0));\n            }\n        } else {\n            if(pos.y < 1.0){\n                pos = vec2(mod(pos.x * modify.x, 1.0), mod(pos.y * modify.y, 1.0));\n            } else {\n                pos = vec2(mod(pos.x * modify.z, 1.0), mod(pos.y * modify.w, 1.0));\n            }\n        }\n    }\n    if(pos.x < 0.5 && pos.y < 0.5) return false;\n    else return true;\n}\n\nvec2 transformPos(vec2 pos, float zoom, float t, float maxi) {\n    pos = (pos - resolution / 2.0) / (2.0 * maxi) / zoom;\n    pos = rotateVec(pos, -t * 2.0 * 6.2831853);\n    pos += vec2(0.2, 0.6);\n    return pos;\n}\n\nvoid main(void) {\n    float maxi = max(resolution.x, resolution.y);\n    float t = mod(time / 30.0, 1.0);\n    float zoom = pow(2.0, t * 8.0);\n    vec2 pos = gl_FragCoord.xy;\n\n    pos = transformPos(pos, zoom, t, maxi);\n\n    float modTimer = mod(time / 50.0, 1.0);\n    vec4 modifier = vec4(\n        step(1.0, mod(modTimer * 16.0, 2.0)),\n        step(1.0, mod(modTimer * 8.0, 2.0)),\n        step(1.0, mod(modTimer * 4.0, 2.0)),\n        step(1.0, mod(modTimer * 2.0, 2.0))\n    );\n    modifier = modifier * 2.0 - 1.0;\n    modifier = vec4(-1.0, 1.0, -1.0, -1.0);\n\n    bool onFractal = getFractal(pos, t, modifier);\n    if(onFractal) { \n        gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0); \n        return;\n    } else {\n        gl_FragColor = vec4(1.0);\n        vec4 sampleColor;\n        float r = 20.0 * rand(pos * 2.0) + 20.0;\n        const int MAX_R = 64;\n        for(int i = 1; i < MAX_R; i ++) {\n            if(i >= int(r)) break;\n            if(gl_FragCoord.x + float(i) > resolution.x || gl_FragCoord.y + float(i) > resolution.y) return;\n            sampleColor = get(gl_FragCoord.xy + vec2(float(i)));\n            if(sampleColor.r - sampleColor.g > 0.9) {\n                gl_FragColor = 0.5 * (1.0 - float(i) / r) * vec4(1.0, 0.0, 0.5, 1.0);\n                if(i > int(r - 2.0)) {gl_FragColor = vec4(1.0, 0.0, 0.5, 1.0);}\n                break;\n            }\n        }\n    }\n    if(time < 0.1) gl_FragColor = vec4(1.0);\n}"
    },
    {
      "name": "Leaf Fractal",
      "date": "2024-11-07",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nvec2 rotateVec(vec2 v, float b) {\n    return vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvec4 get(vec2 coord) {\n    return texture2D(backbuffer, coord/resolution);\n}\n\nbool getFractal(vec2 pos, float t){\n    const int MAX_ITER = 100;\n    int limit = int(10.0 + t * 8.0);\n    for(int i = 0; i < MAX_ITER; i ++) {\n        if(i >= limit) break;\n        pos *= 3.0;\n        if(pos.x < 1.0){\n            if(pos.y < 1.0) {\n                continue;\n            } else if(pos.y < 2.0) {\n                pos = vec2(fract(-pos.x), fract(pos.y));\n            } else {\n                return false;\n            }\n        } else if(pos.x < 2.0) {\n            if(pos.y < 1.0){\n                pos = vec2(fract(-pos.x), fract(-pos.y));\n            } else if(pos.y < 2.0) {\n                pos = vec2(fract(-pos.y), fract(pos.x));\n            } else {\n                return false;\n            }\n        } else {\n            if(pos.y < 1.0){\n                return false;\n            } else if(pos.y < 2.0) {\n                pos = vec2(fract(pos.x), fract(pos.y));\n            } else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvec2 transformPos(vec2 pos, float zoom, float t, float maxi) {\n    pos = (pos - resolution / 2.0) / (2.0 * maxi) / zoom;\n    pos = rotateVec(pos, -t * 6.2831853);\n    pos += vec2(0.5, 0.5);\n    return pos;\n}\n\nvoid main(void) {\n    float maxi = max(resolution.x, resolution.y);\n    float t = mod(time / 30.0, 1.0);\n    float zoom = pow(3.0, t * 8.0);\n    vec2 pos = gl_FragCoord.xy;\n\n    pos = transformPos(pos, zoom, t, maxi);\n\n    bool onFractal = getFractal(pos, t);\n    if(onFractal) { gl_FragColor = vec4(1.0); return;}\n    else {\n        gl_FragColor = vec4(0.0);\n    }\n}"
    },
    {
      "name": "Cracks",
      "date": "2024-11-11",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\nuniform int frame;\n\n\n\nconst float pi = 3.14159265;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(192.9898, 46.14714))) * 43758.5453);}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nfloat crackRoughness(vec2 seed, float distX) {\n\tdistX /= 10.0;\n\tfloat a = rand(seed + floor(distX));\n\tfloat b = rand(seed + ceil(distX));\n\treturn 15.0 * mix(a, b, fract(distX));\n}\n\nvoid main(void) {\n\n\tfloat i = 30.0;\n\tvec2 pos = gl_FragCoord.xy;\n\tfloat f = float(frame);\n\tfloat timeStamp = floor(f/i);\n\tvec3 crack = vec3(resolution.x/4.0 + (resolution.x / 2.0) * rand(vec2(timeStamp, 3.5*timeStamp)), resolution.y / 4.0 + (resolution.y / 2.0) * rand(vec2(timeStamp*4.7, timeStamp*7.15)), pi * rand(vec2(timeStamp*0.67, timeStamp*13.52)));\n\n\tvec2 dist = rotateVec(pos - crack.xy, -crack.z);\n\tfloat r = crackRoughness(crack.xy, dist.x);\n\n\tif(floor(mod(f, i)) == 1.0) {\n\t  if(abs(dist.y + r) < 4.0) {\n\t\t  gl_FragColor = vec4(1.0);\n  \t} else {\n\t  \tgl_FragColor = get(pos);\n\t  }\n\t} else {\n\t\tif(abs(dist.y + r) < 1.0) {\n\t\t  gl_FragColor = vec4(0.0);\n  \t} else {\n\t\t  gl_FragColor = get(pos + rotateVec(vec2(0.0, -1.0 * sign(dist.y + r)), crack.z));\n\t\t  //gl_FragColor = vec4(r/10.0);\n\t  }\n\t}\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Colorful Backbuffer",
      "date": "2024-11-13",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform int frame;\nuniform float time;\nuniform sampler2D backbuffer;///min:l;mag:l;s:r;t:r;\nuniform vec3 daytime;\nconst float pi = 3.14159265359;\n\nconst float scale = 500.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tvec2 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 4; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex), 2.0), floor(float(vertex) / 2.0));\n      float gradAngle = 2.0 * pi * rand(floor(pos/cScale) + vertexOffset);\n      vec2 g = vec2(sin(gradAngle), cos(gradAngle));\n      vec2 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvec4 get(vec2 coord) {\ncoord = mod(coord, resolution);\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvoid main(void) {\n\tvec2 pos = gl_FragCoord.xy;\n\tif(frame == 0) {\n\t\tgl_FragColor = vec4(rand(pos + daytime.z), rand(pos + daytime.y), rand(pos + daytime.x), 1.0); //20.0 * (perlin(pos, 5.0) + 0.1));\n\t} else {\n\t\tfloat t = time * 2.0;\n\t\tvec2 offset = 20.0 * rotateVec(vec2(0.0, rand(pos)), 3.0 * pi * perlin(pos + t + daytime.x * 60.0));\n\t\tvec4 last = get(pos);\n\t\tvec4 change = 0.05 * (get(pos + offset) - vec4(vec3(0.5), 0.0));\n\t\tgl_FragColor = vec4(last.r + change.g, last.g + change.b, last.b - change.r, 1.0);\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Mandelbrot",
      "date": "2024-12-11",
      "code": "precision highp float;\n\nuniform vec2 resolution;\nuniform float time;\n\nconst int iterations = 500;\nconst float speed = 1.0;\n\nfloat sigmoid(float x, float steepness) {\n    float offset = 0.5;\n    float scale = 1.0 / (1.0 + exp(-steepness * (x - offset)));\n    float normalized = (scale - scale * exp(-steepness)) /(1.0 - exp(-steepness));\n    return normalized;\n}\n\nvec2 getOffset(int idx) {\n\tif(idx == 0) return vec2(-0.818128, 0.1988497);\n\telse if(idx == 1) return vec2(-0.743643887037151, 0.131825904205330);\n\telse if(idx == 2) return vec2(-1.62916, -0.020635);\n\telse if(idx == 3) return vec2(-0.761574, -0.0847596);\n\telse if(idx == 4) return vec2(0.2599, 0.0019);\n\telse if(idx == 5) return vec2(0.0, -0.6358);\n\telse if(idx == 6) return vec2(0.099937, 0.640075);\n\telse return vec2(0.0578, -0.65655);\n}\n\nvec2 offset() {\n    float tp = 6.283185307179;\n    float t = time / speed / tp;\n\n    int idxLast = int(mod(floor(t), 8.0));\n    int idxNext = int(mod(ceil(t), 8.0));\n    vec2 last = getOffset(idxLast);\n    vec2 next = getOffset(idxNext);\n\n    return mix(last, next, sigmoid(fract(t), 50.0));\n}\n\nvec3 rainbow(float v) {\n\tv *= 6.283185;\n\treturn 0.5 + 0.5 * vec3(cos(v), cos(v - 2.094395), cos(v + 2.094395));\n}\n\nvec2 compSqrt(vec2 c) {\n    float x2 = c.x * c.x;\n    float y2 = c.y * c.y;\n    return vec2(x2 - y2, 2.0 * c.x * c.y);\n}\n\nvec2 mandelbrot(vec2 c, float zoom) {\n\tfloat x = c.x - 0.25;\n  float y2 = c.y * c.y;\n  float q = x * x + y2;\n  if (q * (q + x) < 0.25 * y2) return vec2(0.0, iterations);\n  if ((c.x + 1.0) * (c.x + 1.0) + y2 < 0.0625) return vec2(0.0, iterations);\n\n  vec2 z = c;\n\tconst int MAX_ITER = 500;\n\tint j = 0;\n\tfor(int i = 0; i < MAX_ITER; i++) {\n\t\t\tz = compSqrt(z);\n\t\t\tz += c;\n\t\t\tif(dot(z, z) > 4.0) return vec2(10.0, i);\n\t\t\tj = i;\n\t}\n\treturn vec2(length(z), j);\n}\n\nvoid main(void) {\n\tfloat zoom = pow(cos(time/speed) * 0.5 + 0.5, 4.0) * 20000000.0 + 500.0;\n\n\tvec2 uv = (gl_FragCoord.yx - resolution.yx / 2.0) / zoom - offset();\n\tvec2 mdb = mandelbrot(-uv, zoom);\n\tfloat v = mdb.y / float(iterations);\n\tif(mdb.x > 2.4) gl_FragColor = vec4(rainbow(v), 1.0);\n}\n\n\n\n\n\n"
    },
    {
      "name": "Julia Set",
      "date": "2024-12-12",
      "code": "precision highp float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 touch;\n\nconst float zoom = 500.0;\nconst int iterations = 500;\nconst vec2 offset = vec2(0., 0.);\n\nvec3 rainbow(float v) {\n\tv *= 6.283185;\n\treturn 0.5 + 0.5 * vec3(cos(v), cos(v - 2.094395), cos(v + 2.094395));\n}\n\nvec2 compSqrt(vec2 c) {\n    float x2 = c.x * c.x;\n    float y2 = c.y * c.y;\n    return vec2(x2 - y2, 2.0 * c.x * c.y);\n}\n\nvec2 mandelbrot(vec2 c, vec2 z) {\n\tint i = 0;\n\tfor(int j = 0; j < iterations; j++) {\n\t\tz = compSqrt(z);\n\t\tz += c;\n\t\tif(dot(z, z) > 4.0) return vec2(10.0, i);\n\t\ti = j;\n\t}\n\treturn vec2(length(z), i);\n}\n\nvoid main(void) {\n\tvec2 uv = (gl_FragCoord.yx - resolution.yx / 2.0) / zoom - offset;\n\tvec2 t = (touch.yx - resolution.yx / 2.0) / resolution.yx * 3.;\n\tvec2 mdb = mandelbrot(t, -uv);\n\tfloat v = mdb.y / float(iterations);\n\tif(mdb.x > 2.4) gl_FragColor = vec4(rainbow(v / 0.1 + 0.72), 1.0);\n}\n\n\n\n\n\n"
    },
    {
      "name": "Color Flows",
      "date": "2024-12-19",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\n//uniform sampler2D backbuffer;///min:l;mag:l;s:r;t:r;\nuniform int frame;\nuniform float time;\nuniform sampler2D backbuffer;///min:n;mag:n;s:r;t:r;\n\nconst float scale = 200.0;\nconst int octaves = 1;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\nconst float pi = 3.14159265359;\n\nvec4 get(vec2 coord) {\ncoord = mod(coord, resolution);\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tvec2 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 4; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex), 2.0), floor(float(vertex) / 2.0));\n      float gradAngle = 2.0 * pi * rand(floor(pos/cScale) + vertexOffset);\n      vec2 g = vec2(sin(gradAngle), cos(gradAngle));\n      vec2 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV + 0.5;\n}\n\nvec4 r(float len, float angle){\n\treturn get(gl_FragCoord.xy + rotateVec(vec2(len), angle));\n}\n\nvoid main(void) {\n\tif(frame == 1) gl_FragColor = vec4(perlin(gl_FragCoord.xy), perlin(gl_FragCoord.xy + vec2(10.0)), perlin(gl_FragCoord.xy + vec2(20.0)), 1.0);\n\telse {\n\t\tfloat angle = perlin(gl_FragCoord.xy + vec2(time * 100.0)) * 20.0;\n\t\tgl_FragColor = vec4(\n\t\t\tr(1.0, angle).r,\n\t\t\tr(3.0, angle).g,\n\t\t\tr(2.0, angle).b,\n\t\t\t1.0\n\t\t);\n  }\n\n}\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Quicksilver",
      "date": "2024-12-21",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform sampler2D backbuffer;///min:l;mag:l;s:r;t:r;\nuniform int frame;\nuniform float time;\n\nconst float scale = 200.0;\nconst int octaves = 2;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\nconst float pi = 3.14159265359;\n\nvec4 get(vec2 coord) {\n\tcoord = mod(coord, resolution);\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat perlin(vec2 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[4];\n\tvec2 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 4; vertex ++) {\n\t\t\tvec2 vertexOffset = vec2(mod(float(vertex), 2.0), floor(float(vertex) / 2.0));\n      float gradAngle = 2.0 * pi * rand(floor(pos/cScale) + vertexOffset);\n      vec2 g = vec2(sin(gradAngle), cos(gradAngle));\n      vec2 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV + 0.5;\n}\n\nvec4 r(float len, float angle){\n\treturn get(gl_FragCoord.xy + rotateVec(vec2(len), angle));\n}\n\nvoid main(void) {\n\tfloat height = perlin(gl_FragCoord.xy);\n\tif(frame == 1) { gl_FragColor = vec4(height);}\n\telse {\n\t\tfloat angle = perlin(gl_FragCoord.xy + vec2(time * 100.0)) * 4.0;\n\t\tfloat dist = angle * 2.0;\n\t\tfloat t = time / 10.0;\n\t\tgl_FragColor = (vec4(\n\t\t\tr(dist * 1.0, angle * 1.0 + t).r,\n\t\t\tr(dist * 1.3, angle * 5.0 + t).r,\n\t\t\tr(dist * 1.6, angle * 8.0 + t).g,\n\t\t\t1.0\n\t\t)-vec4(0.4995)) * 1.003 + vec4(0.5);\n  }\n}\n\n\n"
    },
    {
      "name": "Color sources",
      "date": "2024-12-25",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;///min:n;mag:n;s:r;t:r;\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nconst float scale = 100.0;\nconst int octaves = 2;\nconst float persistance = 0.1;\nconst float lacunarity = 0.07;\nconst float pi = 3.1415926;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nvoid main(void) {\n\tfloat s = 40.;\n\tvec2 pos = gl_FragCoord.xy;\n\tif(distance(mod(pos, 2.*s), vec2(s)) < 5.) {\n\t\tvec2 uv = (-cos(gl_FragCoord.xy / resolution * pi * 2.0) + 1.0) * 0.5;\n\t\tgl_FragColor = vec4(uv, 1.0, 1.0);\n\t} else {\n\t\tfloat pV = perlin3d(vec3(pos, time * 50.0)) * 50.0;\n\t\tvec2 samplePos = pos + rotateVec(vec2(0.0, 3.0), pV);\n    gl_FragColor = get(samplePos) - 0.005;\n\t}\n}\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Color Peel",
      "date": "2025-01-22",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform sampler2D backbuffer;///min:n;mag:n;s:r;t:r;\nuniform vec2 touch;\nuniform int frame;\n\nvec3 palette(int a) {\n\tif(a == 0) return vec3(243., 231., 155.) / 255.;\n\tif(a == 1) return vec3(250., 178., 127.) / 255.;\n\tif(a == 2) return vec3(235., 127., 134.) / 255.;\n\tif(a == 3) return vec3(185., 94., 154.) / 255.;\n\tif(a == 4) return vec3(92., 83., 165.) / 255.;\n}\n\nint getPaletteId(vec3 c) {\n\tfor(int i = 0; i < 5; i ++) {\n\t\tif(length(c - palette(i)) < 0.1) return i;\n\t}\n\treturn -1;\n}\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nfloat bell(float x) {\n\treturn pow(2.7182818, -pow(x, 2.));\n}\n\nvoid main(void) {\n\tvec2 p = gl_FragCoord.xy;\n\tvec4 old = vec4(get(p));\n\tfloat sumH = old.a;\n\tfloat d = distance(p, touch) / 100.0;\n\tsumH += bell(d) * 0.1;\n\tif(sumH > 1.) {\n\t\tint newId = getPaletteId(old.rgb) - 1;\n\t\tif(newId < 0) newId = 4;\n\t\tsumH = fract(sumH);\n\t\tgl_FragColor = vec4(palette(newId), sumH);\n\t} else {\n\t\tgl_FragColor = vec4(old.rgb, sumH);\n\t}\n\n\tif(frame == 0) gl_FragColor = vec4(palette(4), 0.0);\n}\n\n\n\n"
    },
    {
      "name": "Square transition",
      "date": "2025-01-23",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\nconst float size = 240.0;\n\nvec3 palette2(int a) {\n\ta = int(mod(float(a), 7.0));\n\tif(a == 0) return vec3(249, 65, 68) / 255.;\n\tif(a == 1) return vec3(243, 114, 44) / 255.;\n\tif(a == 2) return vec3(248, 150, 30) / 255.;\n\tif(a == 3) return vec3(249, 199, 79) / 255.;\n\tif(a == 4) return vec3(144, 190, 109) / 255.;\n\tif(a == 5) return vec3(67, 170, 139) / 255.;\n\telse return vec3(87, 117, 144) / 255.;\n}\n\nvec3 palette(int a) {\n\ta = int(mod(float(a), 7.0));\n\tif(a == 0) return vec3(114, 186, 213) / 255.;\n\tif(a == 1) return vec3(14, 76, 109) / 255.;\n\tif(a == 2) return vec3(25) / 255.;\n\tif(a == 3) return vec3(1, 38, 61) / 255.;\n\tif(a == 4) return vec3(230, 54, 57) / 255.;\n\tif(a == 5) return vec3(223, 153, 2) / 255.;\n\telse return vec3(154, 25, 51) / 255.;\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nbool inside(vec2 pos, float s, float a) {\n\tvec2 rpos = abs(rotateVec(pos, a * 0.7854));\n\treturn max(rpos.x, rpos.y) > s;\n}\n\nvoid main(void) {\n\tfloat t = time/1.5 + gl_FragCoord.x / 1000.0;\n\tfloat tl = mod(t, 8.0);\n\tbool switched = mod(tl + 2.0, 8.0) > 4.0;\n\tvec2 pos = mod(gl_FragCoord.xy + float(switched) * size/ 2.0, size) / (size/2.0) - 1.0;\n\tfloat c = abs(2.0 - mod(tl, 4.0));\n\tfloat s = (smoothstep(1.0, 2.0, c) - 1.0) * 0.29289 + 1.0;\n\tfloat inv = (float(switched) * 2.0 - 1.0);\n\tfloat a = smoothstep(1.0, -1.0, c) * inv * 2.;\n\n  vec3 c1 = palette(int(floor(t / 8.0 + 3.5)));\n  vec3 c2 = palette(int(floor(t / 8.0)));\n\n  if(inside(pos, s, a) == switched) {\n  \tgl_FragColor = vec4(c1, 1.0);\n  } else {\n  \tgl_FragColor = vec4(c2, 1.0);\n  }\n  //float sqDist = max(abs(gl_FragCoord.x - resolution.x/2.), abs(gl_FragCoord.y - resolution.y/2.));\n  //if(sqDist < 200. || abs(sqDist - 250.) < 10.) {gl_FragColor = 1. - gl_FragColor;}\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Threads",
      "date": "2025-01-28",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nconst float scale = 1000.0;\nconst int octaves = 2;\nconst float persistance = 0.07;\nconst float lacunarity = 0.07;\nconst float pi = 3.1415926;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat getAngle(vec2 coord) {\n\tvec2 c = coord - resolution.xy * 0.5;\n\tfloat angle = atan(c.y / c.x) / (2.0*pi)+ 0.25;\n  if(c.x < 0.0) angle = angle + 0.5;\n\treturn angle * 12.;\n}\n\nvec3 p1(float v) {\n\tv *= 6.283185307179;\n\treturn 0.5 + 0.5 * vec3(0.75 * cos(v - 1.7), 0.3 * cos(v - 3.), 0.5 * cos(v + 1.7));\n}\n\nvoid main(void) {\n\tvec2 pos = gl_FragCoord.xy;\n  float pV = perlin3d(vec3(pos, time * 130.0)) * 50.0;\n  vec2 samplePos = pos + rotateVec(vec2(0.0, 3.0), pV);\n  if(mod(pV + pos.y / 100., 2. * pi) < 0.1) {\n  \tgl_FragColor = vec4(p1(getAngle(pos)), 1.0);\n  } else {\n    gl_FragColor = get(samplePos) - 0.01;\n  }\n}\n\n\n\n\n\n\n\n\n\n"
    },
    {
      "name": "Perlin Fabric",
      "date": "2025-01-28",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nconst float scale = 300.0;\nconst int octaves = 3;\nconst float persistance = 0.3;\nconst float lacunarity = 0.3;\nconst float pi = 3.1415926;\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvec3 p1(float v) {\n\tv *= 6.283185307179;\n\treturn 0.5 + 0.5 * vec3(cos(v), cos(v - 1.5), cos(v + 3.5));\n}\n\nvec3 p2(float v) {\n\tv *= 6.283185307179;\n\treturn 0.5 + 0.5 * vec3(cos(v - 1.7), cos(v - 3.), cos(v + 1.7));\n}\n\nvoid main(void) {\n\tfloat pV = perlin3d(vec3(gl_FragCoord.xy, time * 50.0));\n\tvec3 c = p1(sin(time)/6.- 0.6);\n\tif(fract(pV * 5.) > 0.95) {\n\t\tgl_FragColor = vec4(c, 1.);\n\t} else {\n\t\tvec4 old = get(gl_FragCoord.xy);\n\t\tif(old.w > 0.5) {\n\t\t\tgl_FragColor = vec4(c, 0.);\n\t\t} else {\n\t\t  gl_FragColor = old - 0.002;\n\t\t}\n\t}\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Neural Worms",
      "date": "2025-02-02",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform sampler2D backbuffer;///min:n;mag:n;s:m;t:m;\nuniform int frame;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat filter(int x, int y) {\n    float a = 0.69;\n    float b = -0.9;\n    float c = -0.69;\n    // Map (x, y) to the correct value\n    if(x == -1 && y == -1) return -a;\n    if(x ==  0 && y == -1) return -b;\n    if(x ==  1 && y == -1) return -a;\n    if(x == -1 && y ==  0) return -b;\n    if(x ==  0 && y ==  0) return -c;\n    if(x ==  1 && y ==  0) return -b;\n    if(x == -1 && y ==  1) return -a;\n    if(x ==  0 && y ==  1) return -b;\n    if(x ==  1 && y ==  1) return -a;\n    return 0.0;\n}\n\nfloat inverse_gaussian(float x) {\n  return -1./pow(2., (0.6*pow(x, 2.)))+1.;\n}\n\nfloat activation(float x) {\n  return inverse_gaussian(x);\n}\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvoid main(void) {\n\tfloat conv = 0.;\n\tfor(int x = -1; x <= 1; x ++) {\n\t\tfor(int y = -1; y <= 1; y ++) {\n\t\t  conv += get(gl_FragCoord.xy + vec2(x, y)).r * filter(x, y);\n\t  }\n\t}\n\n\tgl_FragColor = vec4(activation(conv), 0., 0., 1.);\n\tif(frame == 0) gl_FragColor = vec4(rand(gl_FragCoord.xy));\n}\n\n\n\n"
    },
    {
      "name": "Neon Puddle",
      "date": "2025-02-03",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nconst float scale = 300.0;\nconst int octaves = 2;\nconst float persistance = 0.5;\nconst float lacunarity = 0.3;\nconst float pi = 3.1415926;\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n\tfloat cScale = scale;\n\tfloat cAmplitude = 1.0;\n\tfloat layeredPV = 0.0;\n\tfloat cV[8];\n\tvec3 a;\n\tfor(int i = 0; i < octaves; i++) {\n\t\tfor(int vertex = 0; vertex < 8; vertex ++) {\n\t\t\tvec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n      \ta = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n\t\t}\n\t\tlayeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n\t\tcAmplitude *= persistance;\n\t\tcScale *= lacunarity;\n\t}\n\treturn layeredPV;\n}\n\nvoid main(void) {\n\tfloat dist = distance(gl_FragCoord.xy, resolution/2.);\n\tfloat pv = perlin3d(vec3(gl_FragCoord.xy, time * 50.));\n\tfloat pat = (sin(gl_FragCoord.x / 4.) + sin(gl_FragCoord.y / 4.))/4. + 0.5;\n\tvec4 old = get(gl_FragCoord.xy) * vec4(1., 0., 0., 1.);\n\tfloat period = pi * 124./60.;\n\tfloat shocktime = mod(time * period, pi);\n\tif(old.w > 0.5) gl_FragColor = pat * old - vec4(0., 0., 0., 1.);\n\telse gl_FragColor = (old - 0.05);\n\tfor(float i = 1.; i < 14.; i ++) {\n\t\tfloat rad = i * 30. + 150.;\n\t\trad *= pow(pv, float(i) / 50.) * float(i) / 5. * 0.3 + 1.0;\n    if(abs(dist - rad - sin(shocktime + dist/100.) * 10.) < 5.) {\n    \tgl_FragColor = vec4(1., 0., 0., 1.);\n    }\n\t}\n\tfloat chroma = 5.;\n\tgl_FragColor += vec4(0., 0.7 * get(gl_FragCoord.xy - vec2(chroma, 0.)).r, get(gl_FragCoord.xy - vec2(chroma * 2., 0.)).r, 0.);\n}\n\n\n\n\n\n"
    },
    {
      "name": "Layered Squares",
      "date": "2025-02-07",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D backbuffer;\n\nconst float size =120.;\nconst float pi = 3.1415926;\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvec3 color(float i) {\n\ti = i * 5. + time;\n\treturn 0.5 + 0.5 * vec3(cos(i * -0.853 + 5.62), cos(i * 0.258), cos(i * 0.587 - 8.725));\n}\n\nfloat getCV(vec2 pos) {\n\tfloat t = time / 2.;\n\tfloat a = floor(pos.x/size);\n\tfloat b = floor((pos.y + sin(a + t) * 400.)/size);\n\tfloat c = floor((pos.x + (b + t * 2.) * 200.)/size);\n\tfloat d = floor((pos.y + cos(b - a + t / 2.) * 330.)/size);\n\tfloat e = floor((-pos.x + cos(d - b + t / 1.5) * 330.)/size);\n\treturn fract((e+d)/10.);\n}\n\nvec2 rotateVec(vec2 v, float b) {\n\treturn vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\n\nvoid main(void) {\n\tvec2 pos = rotateVec(gl_FragCoord.xy, pi/4.);\n\tgl_FragColor = vec4(color(getCV(pos) + fract(pos.x/3000.)), 1.);\n}\n\n\n\n\n\n\n"
    },
    {
      "name": "Game of life",
      "date": "2025-02-16",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform sampler2D backbuffer;///min:n;mag:n;s:m;t:m;\nuniform int frame;\n\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\n\nfloat filter(int x, int y) {\n\tif(x == 0 && y == 0) return 9.;\n\treturn 1.;\n}\n\nfloat activation(int x) {\n\tif(x == 3 || x == 11 || x == 12) return 1.0;\n  return 0.0;\n}\n\nvec4 get(vec2 coord) {\n\treturn texture2D(backbuffer, coord/resolution);\n}\n\nvoid main(void) {\n\tfloat conv = 0.;\n\tfor(int x = -1; x <= 1; x ++) {\n\t\tfor(int y = -1; y <= 1; y ++) {\n\t\t  conv += get(gl_FragCoord.xy + vec2(x, y)).r * filter(x, y);\n\t  }\n\t}\n\n\tgl_FragColor = vec4(activation(int(conv)), 0., 0., 1.);\n\tif(frame == 0) gl_FragColor = vec4(step(0.7, rand(gl_FragCoord.xy)));\n}\n\n\n\n"
    },
    {
      "name": "Slimy Matter",
      "date": "2025-02-21",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 touch;\n\nconst int octaves = 5;\nconst float lacunarity = 0.5;\nconst float persistance = 0.5;\n\nvec3 rotateVec3(vec3 v, float yaw, float pitch) {\n    float cy = cos(yaw);\n    float sy = sin(yaw);\n    vec3 yawRotated = vec3(\n        cy * v.x - sy * v.z,\n        v.y,\n        sy * v.x + cy * v.z\n    );\n\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    vec3 pitchRotated = vec3(\n        yawRotated.x,\n        cp * yawRotated.y - sp * yawRotated.z,\n        sp * yawRotated.y + cp * yawRotated.z\n    );\n\n    return pitchRotated;\n}\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat noize3d(vec3 pos) {\n\treturn\n\tmix(\n\t  mix(\n\t  \tmix(rand(floor(pos)),rand(vec3(ceil(pos.x), floor(pos.yz))),fract(pos.x)),\n  \t  mix(rand(vec3(floor(pos.x), ceil(pos.y), floor(pos.z))),rand(vec3(ceil(pos.xy), floor(pos.z))),fract(pos.x)),\n  \t\tfract(pos.y)\n  \t), mix(\n\t  \tmix(rand(vec3(floor(pos.xy), ceil(pos.z))),rand(vec3(ceil(pos.x), floor(pos.y), ceil(pos.z))),fract(pos.x)),\n\t  \tmix(rand(vec3(floor(pos.x), ceil(pos.yz))),rand(vec3(ceil(pos))),fract(pos.x)),\n\t  \tfract(pos.y)\n  \t),\n  \tfract(pos.z)\n  );\n}\n\nfloat layeredNoize3d(vec3 pos) {\n\tpos = rotateVec3(pos, 2.4, 1.7);\n\tfloat layered = 0.0;\n\tfor(int layer = 1; layer <= octaves; layer ++) {\n    layered += noize3d(pos) * pow(persistance, float(layer));\n    pos = rotateVec3(pos/lacunarity, 2.4, 1.7);\n\t}\n\treturn layered;\n}\n\nvec3 LN3DD(vec3 pos) {\n\tfloat offset = 0.001;\n\tfloat a = layeredNoize3d(pos);\n\tfloat x = layeredNoize3d(pos + vec3(offset, 0., 0.));\n\tfloat y = layeredNoize3d(pos + vec3(0., offset, 0.));\n\treturn vec3(a/1000., a-x, a-y) * 1000.;\n}\n\nvoid main(void) {\n\tvec3 deriv = LN3DD(vec3(gl_FragCoord.xy/50., time*0.5));\n\tvec2 dir = touch - gl_FragCoord.xy;\n\tfloat dist = length(dir);\n\tdir /= dist;\n\tdist += 10.;\n\n  float intens = dot(deriv.yz, dir)/dist*100. + deriv.x*0.3;\n\tgl_FragColor = vec4(deriv.x + intens, vec3(max(0., intens)));\n}\n\n\n\n"
    },
    {
      "name": "Fluorecant Squares",
      "date": "2025-05-18",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nconst float pi = 3.14159;\nconst float scale = 100.0;\nconst int octaves = 2;\nconst float persistance = 0.5;\nconst float lacunarity = 0.5;\nconst float bloom = 0.05;\nconst float th = 0.5;\n\nfloat rand(vec3 n) {return fract(sin(dot(n, vec3(12.9898, 4.1414, 7.8931))) * 43758.5453);}\nfloat perlin3d(vec3 pos) {\n  float cScale = scale;\n  float cAmplitude = 1.0;\n  float layeredPV = 0.0;\n  float cV[8];\n  vec3 a;\n  for(int i = 0; i < octaves; i++) {\n    for(int vertex = 0; vertex < 8; vertex ++) {\n      vec3 vertexOffset = vec3(mod(float(vertex), 2.0), mod(floor(float(vertex) / 2.0), 2.0), floor(float(vertex) / 4.0));\n      float gradYaw = 2.0 * pi * rand(floor(pos/cScale + 91.0) + vertexOffset);\n      float gradPitch = pi * rand(floor(pos/cScale) + vertexOffset);\n      vec3 g = vec3(sin(gradYaw) * cos(gradPitch), sin(gradYaw) * sin(gradPitch), cos(gradYaw));\n      vec3 o = floor(pos/cScale) + vertexOffset;\n      o = (pos - o * cScale) / cScale;\n      if(vertex == 0) {\n        a = o * o * o * (o * (o * 6.0 - 15.0) + 10.0);\n      }\n      cV[vertex] = dot(g, o);\n    }\n    layeredPV += cAmplitude * mix(mix(mix(cV[0], cV[1], a.x), mix(cV[2], cV[3], a.x), a.y), mix(mix(cV[4], cV[5], a.x), mix(cV[6], cV[7], a.x), a.y), a.z);\n    cAmplitude *= persistance;\n    cScale *= lacunarity;\n  }\n  return layeredPV;\n}\nvec3 rotateVec3(vec3 v, float yaw, float pitch) {\n    float cy = cos(yaw);\n    float sy = sin(yaw);\n    vec3 yawRotated = vec3(\n        cy * v.x - sy * v.z,\n        v.y,\n        sy * v.x + cy * v.z\n    );\n\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    vec3 pitchRotated = vec3(\n        yawRotated.x,\n        cp * yawRotated.y - sp * yawRotated.z,\n        sp * yawRotated.y + cp * yawRotated.z\n    );\n\n    return pitchRotated;\n}\n\nfloat noize3d(vec3 pos) {\n  return\n  mix(\n    mix(\n      mix(rand(floor(pos)),rand(vec3(ceil(pos.x), floor(pos.yz))),fract(pos.x)),\n      mix(rand(vec3(floor(pos.x), ceil(pos.y), floor(pos.z))),rand(vec3(ceil(pos.xy), floor(pos.z))),fract(pos.x)),\n      fract(pos.y)\n    ), mix(\n      mix(rand(vec3(floor(pos.xy), ceil(pos.z))),rand(vec3(ceil(pos.x), floor(pos.y), ceil(pos.z))),fract(pos.x)),\n      mix(rand(vec3(floor(pos.x), ceil(pos.yz))),rand(vec3(ceil(pos))),fract(pos.x)),\n      fract(pos.y)\n    ),\n    fract(pos.z)\n  );\n}\n\nfloat layeredNoize3d(vec3 pos) {\n  pos = rotateVec3(pos, 2.4, 1.7) / 4.;\n  float layered = 0.0;\n  for(int layer = 1; layer <= octaves; layer ++) {\n    layered += noize3d(pos) * pow(persistance, float(layer));\n    pos = rotateVec3(pos/lacunarity, 2.4, 1.7);\n  }\n  return layered;\n}\n\nvoid main(void) {\n  vec2 coord = gl_FragCoord.xy - resolution/2.;\n\n  for(float layer = 0.; layer < 5.; layer ++) {\n    vec2 layerCoord = coord/(200./(layer/5. + 2.));\n    float z = 10. * time + layer;\n    vec2 thisCell = vec2(floor(layerCoord + 0.5));\n    vec2 closest = floor(layerCoord) + 0.5;\n    vec2 offsets = sign(layerCoord - thisCell);\n\n\n    vec3 v = vec3(thisCell, z);\n    float activex = sign(step(th, layeredNoize3d(v)) + step(th, layeredNoize3d(v + vec3(offsets.x, 0., 0.))));\n    float activey = sign(step(th, layeredNoize3d(v)) + step(th, layeredNoize3d(v + vec3(0., offsets.y, 0.))));\n\n    float x = bloom / abs(layerCoord.x - closest.x);\n    float y = bloom / abs(layerCoord.y - closest.y);\n\n\tgl_FragColor += (activex * x + activey * y) * vec4(0.3, 0.5, 1.0, 1.0);\n  }\n}"
    },
    {
      "name": "Glitched out Cube",
      "date": "2025-05-20",
      "code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nconst float pi = 3.1415926;\n\nconst float bloom = 0.05;\nconst float camZ = 3.;\n//const vec4 color = vec4(0.6, 1., 0.3, 1.);\n\nvec3 cube(float i) {\n  return floor(vec3(mod(i, 2.), mod(i, 4.)/2., i/4.));\n}\n\nvec3 floatToAxis(float value) {\n  if (value == 0.) return vec3(1., 0., 0.); // Map 0. to x-axis\n  if (value == 1.) return vec3(0., 1., 0.); // Map 1. to y-axis\n  if (value == 2.) return vec3(0., 0., 1.); // Map 2. to z-axis\n  return vec3(0.); // Default for invalid input\n}\n\nfloat getAngle(vec2 c) {\n  float angle = atan(c.y / c.x) / (2.0*pi)+ 0.25;\n  if(c.x < 0.0) angle = angle + 0.5;\n  return angle * pi * -2. + pi;\n}\n\nvec2 rotateVec(vec2 v, float b) {\n  return vec2(cos(b) * v.x + sin(b) * v.y, cos(b) * v.y - sin(b) * v.x);\n}\n\nfloat distSegm(vec2 v1, vec2 v2, vec2 pos) {\n  vec2 vc = v2-v1;\n  vec2 vcp = pos-v1;\n  float angle = getAngle(vc);\n  vcp = rotateVec(vcp, -angle);\n  if(vcp.y > 0. && vcp.y < length(vc)) {\n    return abs(vcp.x);\n  } else if (vcp.y <= 0.) {\n    return distance(v1, pos);\n  } else {\n    return distance(v2, pos);\n  }\n  return 1.;\n}\n\nvec3 rotateVec3(vec3 v, float yaw, float pitch) {\n  //return v;\n    float cy = cos(yaw);\n    float sy = sin(yaw);\n    vec3 yawRotated = vec3(\n        cy * v.x - sy * v.z,\n        v.y,\n        sy * v.x + cy * v.z\n    );\n\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    vec3 pitchRotated = vec3(\n        yawRotated.x,\n        cp * yawRotated.y - sp * yawRotated.z,\n        sp * yawRotated.y + cp * yawRotated.z\n    );\n\n    return pitchRotated;\n}\n\nvec2 project(vec3 c) {\n  return vec2(c.x/(c.z-camZ), c.y/(c.z-camZ));\n}\n\nfloat rand(float a) {return fract(sin(a * 12.9898) * 43758.5453);}\nfloat rand(vec2 n) {return fract(sin(tan(dot(n, vec2(42.7398, 4.75414))) * 478.5453));}\nfloat rand(vec3 n) {return fract(rand(n.xz) + rand(n.yz) + rand(n.xy));}\n\nfloat smoothNoise(float a) {return fract(a) * rand(ceil(a)) + (1. - fract(a)) * rand(floor(a));}\n\nvec2 glitchFilter(vec2 pos) {\n  float y_h = rand(time) * 100.;\n  float r = rand(vec2(floor(time*10.0), floor(pos.y/ y_h)));\n  if(r <= 0.1) pos.x += 200.0 * r;\n  return pos;\n}\n\nvoid main(void)\n{\n  float t1 = time * 0.33;\n  float t2 = time * 0.77;\n  vec2 pos = glitchFilter(gl_FragCoord.xy);\n  pos = (pos - resolution/2.)/ 250.;\n  float noize = rand(vec3(gl_FragCoord.xy/50., -time));\n\n  vec4 color = vec4(0.1) + 2. * abs(vec4(rotateVec3(vec3(1., 1., 1.), t1, t2), 1.));\n\n  for(float e = 0.; e < 12.; e++) {\n    float dir = floor(e/4.);\n    float v1 = min(7., pow(2., mod(e, 4.)));\n\n    vec3 v1_3 = cube(v1);\n    vec3 v2_3 = mod(v1_3 + floatToAxis(dir), 2.);\n\n    vec2 v1_2 = project(rotateVec3(v1_3*2. - vec3(1.), t1, t2));\n    vec2 v2_2 = project(rotateVec3(v2_3*2. - vec3(1.), t1, t2));\n\n    gl_FragColor += color * smoothNoise(t1) * bloom/distSegm(v1_2, v2_2, pos);\n  }\ngl_FragColor = noize * gl_FragColor;\n}"
    }
  ]
}